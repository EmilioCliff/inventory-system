// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: reports.sql

package db

import (
	"context"
	"time"
)

const getAdminPurchaseOrders = `-- name: GetAdminPurchaseOrders :many
SELECT (SELECT SUM((elem->>'quantity')::integer * (elem->>'unit_price')::integer)
FROM LATERAL (SELECT jsonb_array_elements(lpo_data) AS elem) AS elem) AS total, id, supplier_name, created_at, lpo_data
FROM purchase_orders WHERE created_at BETWEEN $1 AND $2
`

type GetAdminPurchaseOrdersParams struct {
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

type GetAdminPurchaseOrdersRow struct {
	Total        int64     `json:"total"`
	ID           string    `json:"id"`
	SupplierName string    `json:"supplier_name"`
	CreatedAt    time.Time `json:"created_at"`
	LpoData      []byte    `json:"lpo_data"`
}

func (q *Queries) GetAdminPurchaseOrders(ctx context.Context, arg GetAdminPurchaseOrdersParams) ([]GetAdminPurchaseOrdersRow, error) {
	rows, err := q.db.Query(ctx, getAdminPurchaseOrders, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAdminPurchaseOrdersRow{}
	for rows.Next() {
		var i GetAdminPurchaseOrdersRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.SupplierName,
			&i.CreatedAt,
			&i.LpoData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllInvoiceSummaryBtwnPeriod = `-- name: GetAllInvoiceSummaryBtwnPeriod :many
SELECT i.invoice_number, i.invoice_data, 
	(SELECT COALESCE(SUM((elem->>'totalBill')::integer), 0)
     	FROM LATERAL (
            SELECT jsonb_array_elements(i.invoice_data) AS elem 
            OFFSET 1
        ) AS elem) AS total, i.invoice_date, u.username
FROM invoices i JOIN users u ON u.user_id = i.user_invoice_id
WHERE invoice_date BETWEEN $1 AND $2
`

type GetAllInvoiceSummaryBtwnPeriodParams struct {
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

type GetAllInvoiceSummaryBtwnPeriodRow struct {
	InvoiceNumber string      `json:"invoice_number"`
	InvoiceData   []byte      `json:"invoice_data"`
	Total         interface{} `json:"total"`
	InvoiceDate   time.Time   `json:"invoice_date"`
	Username      string      `json:"username"`
}

func (q *Queries) GetAllInvoiceSummaryBtwnPeriod(ctx context.Context, arg GetAllInvoiceSummaryBtwnPeriodParams) ([]GetAllInvoiceSummaryBtwnPeriodRow, error) {
	rows, err := q.db.Query(ctx, getAllInvoiceSummaryBtwnPeriod, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllInvoiceSummaryBtwnPeriodRow{}
	for rows.Next() {
		var i GetAllInvoiceSummaryBtwnPeriodRow
		if err := rows.Scan(
			&i.InvoiceNumber,
			&i.InvoiceData,
			&i.Total,
			&i.InvoiceDate,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllReceiptSummaryBtwnPeriod = `-- name: GetAllReceiptSummaryBtwnPeriod :many
SELECT r.receipt_number, r.receipt_data, t.amount, r.payment_method, r.created_at, t.mpesa_receipt_number, t.phone_number, u.username
FROM receipts r JOIN transactions t ON r.receipt_number = t.transaction_id
JOIN users u ON u.user_id = r.user_receipt_id
WHERE r.created_at BETWEEN $1 AND $2
`

type GetAllReceiptSummaryBtwnPeriodParams struct {
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

type GetAllReceiptSummaryBtwnPeriodRow struct {
	ReceiptNumber      string    `json:"receipt_number"`
	ReceiptData        []byte    `json:"receipt_data"`
	Amount             int32     `json:"amount"`
	PaymentMethod      string    `json:"payment_method"`
	CreatedAt          time.Time `json:"created_at"`
	MpesaReceiptNumber string    `json:"mpesa_receipt_number"`
	PhoneNumber        string    `json:"phone_number"`
	Username           string    `json:"username"`
}

func (q *Queries) GetAllReceiptSummaryBtwnPeriod(ctx context.Context, arg GetAllReceiptSummaryBtwnPeriodParams) ([]GetAllReceiptSummaryBtwnPeriodRow, error) {
	rows, err := q.db.Query(ctx, getAllReceiptSummaryBtwnPeriod, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllReceiptSummaryBtwnPeriodRow{}
	for rows.Next() {
		var i GetAllReceiptSummaryBtwnPeriodRow
		if err := rows.Scan(
			&i.ReceiptNumber,
			&i.ReceiptData,
			&i.Amount,
			&i.PaymentMethod,
			&i.CreatedAt,
			&i.MpesaReceiptNumber,
			&i.PhoneNumber,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserInvoiceSummaryBtwnPeriod = `-- name: GetUserInvoiceSummaryBtwnPeriod :many
SELECT invoice_number, invoice_data, 
	(SELECT COALESCE(SUM((elem->>'totalBill')::integer), 0)
     	FROM LATERAL (
            SELECT jsonb_array_elements(invoice_data) AS elem 
            OFFSET 1
        ) AS elem) AS total, invoice_date
FROM invoices WHERE user_invoice_id = $1 AND invoice_date BETWEEN $2 AND $3
`

type GetUserInvoiceSummaryBtwnPeriodParams struct {
	UserID   int32     `json:"user_id"`
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

type GetUserInvoiceSummaryBtwnPeriodRow struct {
	InvoiceNumber string      `json:"invoice_number"`
	InvoiceData   []byte      `json:"invoice_data"`
	Total         interface{} `json:"total"`
	InvoiceDate   time.Time   `json:"invoice_date"`
}

func (q *Queries) GetUserInvoiceSummaryBtwnPeriod(ctx context.Context, arg GetUserInvoiceSummaryBtwnPeriodParams) ([]GetUserInvoiceSummaryBtwnPeriodRow, error) {
	rows, err := q.db.Query(ctx, getUserInvoiceSummaryBtwnPeriod, arg.UserID, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserInvoiceSummaryBtwnPeriodRow{}
	for rows.Next() {
		var i GetUserInvoiceSummaryBtwnPeriodRow
		if err := rows.Scan(
			&i.InvoiceNumber,
			&i.InvoiceData,
			&i.Total,
			&i.InvoiceDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserReceiptPaidTotal = `-- name: GetUserReceiptPaidTotal :one
SELECT COALESCE(SUM(t.amount), 0) AS receipt_total
FROM receipts r JOIN transactions t ON r.receipt_number = t.transaction_id 
WHERE r.user_receipt_id = $1 AND r.created_at BETWEEN $2 AND $3
`

type GetUserReceiptPaidTotalParams struct {
	UserID   int32     `json:"user_id"`
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

func (q *Queries) GetUserReceiptPaidTotal(ctx context.Context, arg GetUserReceiptPaidTotalParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserReceiptPaidTotal, arg.UserID, arg.FromDate, arg.ToDate)
	var receipt_total interface{}
	err := row.Scan(&receipt_total)
	return receipt_total, err
}

const getUserReceiptSummaryBtwnPeriod = `-- name: GetUserReceiptSummaryBtwnPeriod :many
SELECT r.receipt_number, r.receipt_data, t.amount, r.payment_method, r.created_at,  t.mpesa_receipt_number, t.phone_number
FROM receipts r JOIN transactions t ON r.receipt_number = t.transaction_id
WHERE user_receipt_id = $1 AND r.created_at BETWEEN $2 AND $3
`

type GetUserReceiptSummaryBtwnPeriodParams struct {
	UserID   int32     `json:"user_id"`
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

type GetUserReceiptSummaryBtwnPeriodRow struct {
	ReceiptNumber      string    `json:"receipt_number"`
	ReceiptData        []byte    `json:"receipt_data"`
	Amount             int32     `json:"amount"`
	PaymentMethod      string    `json:"payment_method"`
	CreatedAt          time.Time `json:"created_at"`
	MpesaReceiptNumber string    `json:"mpesa_receipt_number"`
	PhoneNumber        string    `json:"phone_number"`
}

func (q *Queries) GetUserReceiptSummaryBtwnPeriod(ctx context.Context, arg GetUserReceiptSummaryBtwnPeriodParams) ([]GetUserReceiptSummaryBtwnPeriodRow, error) {
	rows, err := q.db.Query(ctx, getUserReceiptSummaryBtwnPeriod, arg.UserID, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserReceiptSummaryBtwnPeriodRow{}
	for rows.Next() {
		var i GetUserReceiptSummaryBtwnPeriodRow
		if err := rows.Scan(
			&i.ReceiptNumber,
			&i.ReceiptData,
			&i.Amount,
			&i.PaymentMethod,
			&i.CreatedAt,
			&i.MpesaReceiptNumber,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStockDistributed = `-- name: GetUserStockDistributed :one
SELECT COALESCE(SUM((elem->>'totalBill')::integer), 0) AS invoice_total
FROM invoices i, LATERAL (
    SELECT jsonb_array_elements(i.invoice_data) AS elem
    OFFSET 1
) AS elems
WHERE i.user_invoice_id = $1 AND i.invoice_date BETWEEN $2
AND $3
`

type GetUserStockDistributedParams struct {
	UserID   int32     `json:"user_id"`
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

func (q *Queries) GetUserStockDistributed(ctx context.Context, arg GetUserStockDistributedParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserStockDistributed, arg.UserID, arg.FromDate, arg.ToDate)
	var invoice_total interface{}
	err := row.Scan(&invoice_total)
	return invoice_total, err
}
