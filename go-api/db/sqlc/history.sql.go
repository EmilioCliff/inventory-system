// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: history.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getInvoicesByDate = `-- name: GetInvoicesByDate :many
SELECT 
    DATE_TRUNC('day', created_at)::timestamp AS issued_date, 
    COUNT(*) AS num_invoices, 
    JSON_AGG(invoice_data) AS invoice_data
FROM 
    invoices
GROUP BY 
    issued_date
ORDER BY 
    issued_date
`

type GetInvoicesByDateRow struct {
	IssuedDate  pgtype.Timestamp `json:"issued_date"`
	NumInvoices int64            `json:"num_invoices"`
	InvoiceData []byte           `json:"invoice_data"`
}

func (q *Queries) GetInvoicesByDate(ctx context.Context) ([]GetInvoicesByDateRow, error) {
	rows, err := q.db.Query(ctx, getInvoicesByDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvoicesByDateRow{}
	for rows.Next() {
		var i GetInvoicesByDateRow
		if err := rows.Scan(&i.IssuedDate, &i.NumInvoices, &i.InvoiceData); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReceiptsByDate = `-- name: GetReceiptsByDate :many
SELECT
    DATE_TRUNC('day', created_at)::timestamp AS issued_date,
    COUNT(*) AS num_receipts,
    JSON_AGG(receipt_data) AS receipt_data
FROM 
    receipts
GROUP BY
    issued_date
ORDER BY
    issued_date
`

type GetReceiptsByDateRow struct {
	IssuedDate  pgtype.Timestamp `json:"issued_date"`
	NumReceipts int64            `json:"num_receipts"`
	ReceiptData []byte           `json:"receipt_data"`
}

func (q *Queries) GetReceiptsByDate(ctx context.Context) ([]GetReceiptsByDateRow, error) {
	rows, err := q.db.Query(ctx, getReceiptsByDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReceiptsByDateRow{}
	for rows.Next() {
		var i GetReceiptsByDateRow
		if err := rows.Scan(&i.IssuedDate, &i.NumReceipts, &i.ReceiptData); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserInvoicesByDate = `-- name: GetUserInvoicesByDate :many
SELECT 
    DATE_TRUNC('day', created_at)::timestamp AS issued_date, 
    COUNT(*) AS num_invoices, 
    JSON_AGG(invoice_data) AS invoice_data
FROM 
    invoices
WHERE
    user_invoice_id = $1
GROUP BY 
    issued_date
ORDER BY 
    issued_date
`

type GetUserInvoicesByDateRow struct {
	IssuedDate  pgtype.Timestamp `json:"issued_date"`
	NumInvoices int64            `json:"num_invoices"`
	InvoiceData []byte           `json:"invoice_data"`
}

func (q *Queries) GetUserInvoicesByDate(ctx context.Context, userInvoiceID int32) ([]GetUserInvoicesByDateRow, error) {
	rows, err := q.db.Query(ctx, getUserInvoicesByDate, userInvoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserInvoicesByDateRow{}
	for rows.Next() {
		var i GetUserInvoicesByDateRow
		if err := rows.Scan(&i.IssuedDate, &i.NumInvoices, &i.InvoiceData); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserReceiptsByDate = `-- name: GetUserReceiptsByDate :many
SELECT
    DATE_TRUNC('day', created_at)::timestamp AS issued_date,
    COUNT(*) AS num_receipts,
    JSON_AGG(receipt_data) AS receipt_data
FROM 
    receipts
WHERE
    user_receipt_id = $1
GROUP BY
    issued_date
ORDER BY
    issued_date
`

type GetUserReceiptsByDateRow struct {
	IssuedDate  pgtype.Timestamp `json:"issued_date"`
	NumReceipts int64            `json:"num_receipts"`
	ReceiptData []byte           `json:"receipt_data"`
}

func (q *Queries) GetUserReceiptsByDate(ctx context.Context, userReceiptID int32) ([]GetUserReceiptsByDateRow, error) {
	rows, err := q.db.Query(ctx, getUserReceiptsByDate, userReceiptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserReceiptsByDateRow{}
	for rows.Next() {
		var i GetUserReceiptsByDateRow
		if err := rows.Scan(&i.IssuedDate, &i.NumReceipts, &i.ReceiptData); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
